# Проект: CPC Auto Helper (Стартовый этап MVP)

## 1. Общее Описание

**Цель:** Разработка веб-приложения (SaaS) для помощи специалистам по контекстной рекламе Яндекс.Директ. Сервис должен автоматизировать рутинные задачи сбора/анализа статистики и предоставлять рекомендации.

**Технологический стек (Старт MVP):**
*   **Backend:** Python 3.x, Flask
*   **Структура:** Flask Blueprints - **ДОБАВЛЕНО**
*   **Работа с БД:** Flask-SQLAlchemy (ORM), SQLAlchemy
*   **База данных:** SQLite (файл `tokens.db`)
*   **HTTP Запросы:** Requests
*   **Парсинг данных:** Модуль `csv` Python - **ДОБАВЛЕНО**
*   **Конфигурация:** python-dotenv (для `.env` файла)
*   **Frontend:** Простейший HTML, генерируемый напрямую из Flask.

**Окружение Разработки:**
*   **ОС:** Windows 10/11
*   **Python:** Версия 3.x (установлен)
*   **Виртуальное окружение:** Используется `venv`
*   **Менеджер пакетов:** `pip`

**Структура проекта (Планируемая с Blueprints):**
```
C:\python\cpc_auto_star\
├── venv\                 # Виртуальное окружение
├── instance/             # Папка Flask для instance-файлов
│   └── tokens.db         # Файл базы данных SQLite - СОЗДАН
├── app/                  # Основная папка приложения - **НОВОЕ**
│   ├── __init__.py       # Инициализация приложения, регистрация Blueprints
│   ├── models.py         # Модель SQLAlchemy (Token) - **ПЕРЕМЕСТИТЬ**
│   ├── auth/             # Blueprint для аутентификации - **НОВОЕ**
│   │   ├── __init__.py   # Инициализация Blueprint 'auth'
│   │   └── routes.py     # Роуты для '/', /login, /callback, /get_token, /logout - **ПЕРЕМЕСТИТЬ**
│   │   └── utils.py      # Вспомогательные функции (get_valid_token, refresh_access_token) - **ПЕРЕМЕСТИТЬ**
│   ├── reports/          # Blueprint для отчетов - **НОВОЕ**
│   │   ├── __init__.py   # Инициализация Blueprint 'reports'
│   │   └── routes.py     # Роуты для /campaigns, /campaign/<id>/platforms и т.д. - **ПЕРЕМЕСТИТЬ/СОЗДАТЬ**
│   │   └── utils.py      # Функции для работы с API Reports (fetch_direct_report и т.д.) - **СОЗДАТЬ**
│   └── templates/        # (Опционально) Папка для HTML шаблонов Flask
│       └── ...
├── .env                  # Ключи API Яндекса - СОЗДАН, ЗАПОЛНЕН
├── .gitignore            # Правила игнорирования для Git (вкл. instance/, *.db, __pycache__/) - ОБНОВЛЕН
├── requirements.txt      # Список зависимостей - ОБНОВЛЕН
├── run.py                # Файл для запуска приложения (импортирует app из app/) - **СОЗДАТЬ/ПЕРЕИМЕНОВАТЬ**
└── PROJECT_README.md     # Этот файл
```
*(Примечание: Текущий `app.py` будет разделен на `run.py`, `app/__init__.py`, `app/models.py`, `app/auth/routes.py`, `app/auth/utils.py`, `app/reports/routes.py`, `app/reports/utils.py`)*

## 2. Текущий Статус (Что уже сделано)

*   [x] Создана базовая структура папок проекта (без Blueprints).
*   [x] Настроено виртуальное окружение и установлены зависимости.
*   [x] Настроен `.env` и `.gitignore`.
*   [x] Реализован полный цикл Яндекс OAuth (авторизация, получение/обмен токенов).
*   [x] Реализовано получение `client_login`.
*   [x] Настроена интеграция Flask-SQLAlchemy и создана БД SQLite (`tokens.db`).
*   [x] Определена модель `Token` и реализовано сохранение/чтение токенов в/из БД.
*   [x] Реализована проверка истечения `access_token` (`expires_at`).
*   [x] Реализована логика автоматического обновления `access_token` с помощью `refresh_token` (функции `get_valid_token`, `refresh_access_token`).
*   [x] Реализован тестовый вызов к API Директа (получение списка кампаний) с использованием обновляемого токена.
*   [x] Реализован базовый механизм сессий Flask для хранения `client_login` между запросами.
*   [ ] Код реорганизован с использованием Flask Blueprints.
*   [ ] Реализован запрос к API Reports для получения отчета по площадкам (PLACEMENT_REPORT).
*   [ ] Реализован цикл ожидания готовности отчета API Reports.
*   [ ] Реализован парсинг TSV-ответа от API Reports.
*   [ ] Реализовано отображение списка кампаний пользователя.
*   [ ] Реализовано отображение отчета по площадкам для выбранной кампании.

## 3. ЗАДАЧА ДЛЯ CURSOR НА СЕЙЧАС: Рефакторинг на Blueprints и Реализация Отчета по Площадкам

**Цель:** Реорганизовать код приложения с использованием Flask Blueprints для лучшей структурированности и реализовать первую ключевую функцию MVP – получение и отображение отчета по площадкам РСЯ для выбранной рекламной кампании через API Яндекс.Директ Reports.

**Разбивка на подзадачи (для последовательной работы):**

**Подзадача 3.1: Рефакторинг - Структура и Blueprint 'auth'**

*   **Действия:**
    1.  Создать папку `app/` и внутри нее `__init__.py`.
    2.  Создать файл `run.py` в корне проекта (для запуска).
    3.  Переместить инициализацию Flask `app`, настройку `SECRET_KEY`, `SQLALCHEMY_*`, `db`, загрузку `.env` в `app/__init__.py`. Функция `create_app()` является хорошим паттерном.
    4.  Создать папку `app/auth/` с `__init__.py` и `routes.py`.
    5.  Создать Blueprint `auth_bp` в `app/auth/__init__.py`.
    6.  Перенести модель `Token` в `app/models.py` (импортировать `db` из `app`).
    7.  Перенести роуты `/`, `/login/yandex`, `/oauth/callback`, `/get_token`, `/logout` в `app/auth/routes.py` (использовать `@auth_bp.route(...)`).
    8.  Перенести функции `get_valid_token`, `refresh_access_token` в `app/auth/utils.py` (или оставить в `routes.py`, если они используются только там).
    9.  Зарегистрировать `auth_bp` в `app/__init__.py`.
    10. Обновить импорты во всех файлах (`url_for('auth.index')`, импорт `db`, `Token`, функций и т.д.).
    11. Обновить `run.py` для импорта и запуска `create_app()`.
*   **Проверка:** Запустить `flask run` (или `python run.py`) и убедиться, что все страницы аутентификации (вход, получение токена, выход) работают как раньше.

**Подзадача 3.2: Рефакторинг - Blueprint 'reports' и Список Кампаний**

*   **Действия:**
    1.  Создать папку `app/reports/` с `__init__.py` и `routes.py`.
    2.  Создать Blueprint `reports_bp` в `app/reports/__init__.py`.
    3.  Перенести роут `/test_api` (который получает список кампаний) в `app/reports/routes.py`. Переименовать его в `/campaigns` (эндпоинт `reports.campaigns`).
    4.  Зарегистрировать `reports_bp` в `app/__init__.py`.
    5.  Обновить импорты.
    6.  Изменить HTML, возвращаемый роутом `/campaigns`, чтобы он отображал список кампаний, где каждая кампания (ее ID) является ссылкой на будущий роут отчета по площадкам (например, `url_for('reports.platforms_report', campaign_id=campaign['Id'])`).
*   **Проверка:** После входа перейти на `/campaigns` и убедиться, что список кампаний отображается со ссылками.

**Подзадача 3.3: API Reports - Функция Заказа, Ожидания и Парсинга Отчета**

*   **Действия:**
    1.  Создать файл `app/reports/utils.py`.
    2.  Создать в нем функцию `fetch_placement_report(access_token, client_login, campaign_id)`:
        *   **Заказ отчета:**
            *   Сформировать `ReportDefinition` для `PLACEMENT_REPORT` по `campaign_id` (за последние 7 или 14 дней, формат TSV). Включить поля: `Placement`, `Impressions`, `Clicks`, `Cost`, `Conversions` (или `Goal` + `Conversions`), `BounceRate` (уточнить имена полей в документации API v5 Reports).
            *   Отправить POST-запрос на URL API Reports. Получить `ReportID`. Обработать ошибки.
        *   **Ожидание:**
            *   Реализовать цикл `while` с максимальным количеством попыток (например, 10-15) и `time.sleep(5)` между ними.
            *   В цикле делать GET-запрос к API Reports с `ReportID` для получения статуса.
            *   Если статус `DONE`, выйти из цикла.
            *   Если статус `ERROR`, выйти из цикла и вернуть ошибку.
            *   Если превышено число попыток, выйти и вернуть ошибку таймаута.
        *   **Скачивание и Парсинг:**
            *   Если статус `DONE`, получить URL для скачивания из ответа.
            *   Скачать содержимое отчета с помощью `requests.get()`. Проверить кодировку (должна быть UTF-8).
            *   Использовать `io.StringIO` и `csv.reader(..., delimiter='\t')` для парсинга TSV-данных.
            *   Пропустить строки заголовков в начале файла (обычно 2 строки).
            *   Преобразовать строки в список словарей, где ключи - это названия столбцов из третьей строки файла отчета. Преобразовать числовые значения в `int` или `float` по необходимости.
            *   Вернуть список словарей с данными.
        *   Вернуть `None` или сообщение об ошибке в случае неудачи на любом этапе.
    3.  Импортировать `time`, `csv`, `io`.
*   **Проверка:** Можно временно создать тестовый роут, который вызывает эту функцию для конкретной кампании и выводит результат в консоль или на страницу.

**Подзадача 3.4: Интеграция - Роут и Отображение Отчета по Площадкам**

*   **Действия:**
    1.  В `app/reports/routes.py` создать новый роут: `@reports_bp.route('/campaign/<int:campaign_id>/platforms')` (эндпоинт `reports.platforms_report`).
    2.  Внутри роута:
        *   Получить `client_login` из сессии.
        *   Получить действительный `access_token`, вызвав `get_valid_token(client_login)` (импортировать из `app.auth.utils`). Если токен не получен, редирект на авторизацию.
        *   Вызвать функцию `fetch_placement_report(access_token, client_login, campaign_id)`.
        *   Если отчет получен (список словарей):
            *   Сгенерировать простой HTML с таблицей (`<table>`, `<thead>`, `<tbody>`), отображающей данные отчета (Площадка, Клики, Расход и т.д.).
            *   Вернуть этот HTML.
        *   Если произошла ошибка при получении отчета:
            *   Вернуть HTML с сообщением об ошибке.
*   **Проверка:** Зайти на `/campaigns`, кликнуть по ссылке на одну из кампаний. Убедиться, что запускается генерация отчета (можно следить по логам/print'ам в консоли) и через некоторое время отображается таблица с данными по площадкам или сообщение об ошибке.

**Важные Замечания для Cursor:**
*   Обращай внимание на правильные импорты между Blueprints и модулями.
*   Используй `url_for` с указанием Blueprint (например, `url_for('auth.login_yandex')`, `url_for('reports.campaigns')`).
*   В документации API Reports Яндекса уточни точные `FieldNames` и структуру ответа.
*   Помни про ограничение `time.sleep()` - это временное решение для MVP.
*   Тщательно обрабатывай ошибки на всех этапах работы с API Reports.
*   Парсинг TSV: не забудь про `delimiter='\t'` и пропуск строк заголовка.

## 4. Следующие Шаги (После выполнения текущей задачи)

*   [ ] Реализовать аналогичный отчет по Поисковым Запросам (`SEARCH_QUERY_PERFORMANCE_REPORT`).
*   [ ] Добавить базовую обработку (идентификацию) "проблемных" площадок/запросов на основе простых правил (как в исходной идее).
*   [ ] Реализовать функцию блокировки площадок/добавления минус-слов через API Директа (сервис Campaigns).
*   [ ] Продумать и реализовать шифрование токенов в БД (Технический долг!).
*   [ ] Заменить `time.sleep()` на фоновые задачи (например, с Celery или RQ) для ожидания отчетов.
*   [ ] Улучшить UI/UX (использование шаблонизатора Jinja2, CSS).

```

