
# Проект: CPC Auto Helper (Стартовый этап MVP)

## 1. Общее Описание

**Цель:** Разработка веб-приложения (SaaS) для помощи специалистам по контекстной рекламе Яндекс.Директ. Сервис должен автоматизировать рутинные задачи сбора/анализа статистики и предоставлять рекомендации.

**Технологический стек (Старт MVP):**
*   **Backend:** Python 3.x, Flask
*   **Работа с БД:** Flask-SQLAlchemy (ORM), SQLAlchemy
*   **База данных:** SQLite (файл `tokens.db`)
*   **HTTP Запросы:** Requests
*   **Конфигурация:** python-dotenv (для `.env` файла)
*   **Frontend:** Простейший HTML, генерируемый напрямую из Flask.

**Окружение Разработки:**
*   **ОС:** Windows 10/11
*   **Python:** Версия 3.x (установлен)
*   **Виртуальное окружение:** Используется `venv`, расположено в `C:\python\cpc_auto_star\venv\`
*   **Менеджер пакетов:** `pip`

**Структура проекта:**

C:\python\cpc_auto_star\
├── venv\                 # Виртуальное окружение
├── instance/             # Папка Flask для instance-файлов (может содержать tokens.db)
│   └── tokens.db         # Файл базы данных SQLite - СОЗДАН
├── .env                  # Ключи API Яндекса (YANDEX_CLIENT_ID, YANDEX_CLIENT_SECRET) - СОЗДАН, ЗАПОЛНЕН
├── .gitignore            # Правила игнорирования для Git (включая *.db, instance/) - ОБНОВЛЕН
├── app.py                # Основной файл приложения Flask - OAuth + DB сохранение/чтение
├── requirements.txt      # Список зависимостей - ОБНОВЛЕН
└── PROJECT_README.md     # Этот файл```
*(Примечание: Flask может создавать папку `instance` для файлов вроде SQLite БД. Убедись, что и `instance/`, и `*.db` добавлены в `.gitignore`)*

## 2. Текущий Статус (Что уже сделано)

*   [x] Создана структура папок проекта.
*   [x] Инициализировано виртуальное окружение `venv`.
*   [x] Установлены зависимости (`Flask`, `requests`, `python-dotenv`, `Flask-SQLAlchemy`).
*   [x] Зафиксированы зависимости в `requirements.txt`.
*   [x] Создан и заполнен файл `.env`.
*   [x] Создан файл `.gitignore`.
*   [x] Создан файл `app.py`.
*   [x] Получены Client ID и Client Secret от Яндекс OAuth.
*   [x] Реализован базовый Flask сервер.
*   [x] Реализован OAuth-флоу (редирект, callback, обмен code на токены).
*   [x] Реализовано получение `client_login`.
*   [x] Настроена интеграция Flask-SQLAlchemy.
*   [x] Определена модель данных `Token`.
*   [x] Создана база данных SQLite (`tokens.db`) с таблицей `token`.
*   [x] Логика сохранения/обновления токенов (`access_token`, `refresh_token`, `expires_at`) реализована в БД (роут `/get_token`).
*   [x] Логика чтения `access_token` из БД реализована (роут `/test_api_call`).
*   [x] `client_login` сохраняется в сессии Flask для идентификации пользователя между запросами.
*   [ ] Реализована проверка истечения `access_token` (`expires_at`).
*   [ ] Реализована логика автоматического обновления `access_token` с помощью `refresh_token`.

## 3. ЗАДАЧА ДЛЯ CURSOR НА СЕЙЧАС: Реализация Автоматического Обновления Токена

**Цель:** Добавить в приложение логику, которая будет проверять время жизни `access_token` перед его использованием и автоматически обновлять его с помощью `refresh_token`, если он истек.

**Разбивка на подзадачи:**

**Подзадача 3.1: Рефакторинг - Вынос Логики Получения и Проверки Токена**

*   **Цель:** Избежать дублирования кода и сделать его чище.
*   **В файле `app.py`:**
    1.  Создать новую функцию, например, `get_valid_token(client_login)`:
        *   Принимает `client_login` в качестве аргумента.
        *   Ищет `Token` в БД по `client_login`.
        *   Если не найден, возвращает `None` или вызывает исключение.
        *   Если найден, **проверяет `token_entry.expires_at`**:
            *   Сравнивает с `datetime.utcnow()` (с небольшим запасом, например, `- timedelta(minutes=1)`).
            *   **Если токен действителен:** возвращает `token_entry.access_token`.
            *   **Если токен истек:**
                *   Проверяет, есть ли `token_entry.refresh_token`.
                *   **Если `refresh_token` есть:**
                    *   Вызывает другую новую функцию (см. Подзадачу 3.2) `refresh_access_token(token_entry)` для обновления токена.
                    *   Если обновление успешно, возвращает *новый* `access_token`.
                    *   Если обновление не удалось, возвращает `None` или вызывает исключение.
                *   **Если `refresh_token` нет:** возвращает `None` или вызывает исключение (требуется полная переавторизация).
        *   Эта функция будет использоваться везде, где нужен актуальный `access_token`.
    2.  Изменить роут `/test_api_call`:
        *   Получить `client_login` из сессии.
        *   Вызвать `get_valid_token(client_login)`, чтобы получить `access_token`.
        *   Обработать случай, если `get_valid_token` вернул `None` (например, редирект на главную с сообщением "Нужна авторизация").
        *   Использовать полученный `access_token` для вызова API Директа.

**Подзадача 3.2: Реализация Функции Обновления Токена**

*   **В файле `app.py`:**
    1.  Создать новую функцию, например, `refresh_access_token(token_entry)`:
        *   Принимает объект `token_entry` (запись из БД) в качестве аргумента.
        *   Проверяет наличие `token_entry.refresh_token`. Если нет, возвращает `False` (или исключение).
        *   Формирует `payload` для запроса на `https://oauth.yandex.ru/token`:
            *   `grant_type=refresh_token`
            *   `refresh_token=token_entry.refresh_token`
            *   `client_id=YANDEX_CLIENT_ID`
            *   `client_secret=YANDEX_CLIENT_SECRET`
        *   Отправляет POST-запрос (используя `requests`).
        *   **Обрабатывает ответ:**
            *   **В случае успеха:**
                *   Получает новый `access_token`, `expires_in`, и *возможно* новый `refresh_token`.
                *   Рассчитывает новое `expires_at_dt`.
                *   Обновляет поля в переданном объекте `token_entry` ( `access_token`, `expires_at`).
                *   Обновляет `refresh_token` в `token_entry`, *только если* он пришел в ответе.
                *   Сохраняет изменения в БД: `db.session.commit()`.
                *   Возвращает `True` (успех).
            *   **В случае ошибки (например, невалидный `refresh_token`):**
                *   Логирует ошибку.
                *   Возвращает `False` (неудача). Можно также удалить невалидный `refresh_token` из `token_entry` и сохранить (`db.session.commit()`), чтобы не пытаться использовать его снова.
*   **Важно:** Эта функция должна изменять объект `token_entry` и сохранять изменения в БД.

**Подзадача 3.3: Интеграция и Тестирование**

*   Убедиться, что `get_valid_token` правильно вызывает `refresh_access_token` и обрабатывает результат.
*   Убедиться, что `/test_api_call` использует `get_valid_token`.
*   **Тестирование:**
    *   Авторизуйся как обычно. Убедись, что `/test_api` работает.
    *   **Имитация истечения токена:** Вручную измени значение `expires_at` в файле `tokens.db` на прошедшую дату (используй DB Browser for SQLite или подобный инструмент).
    *   Снова зайди на `/test_api`. Приложение должно:
        *   Обнаружить, что токен истек.
        *   Использовать `refresh_token` для получения нового `access_token`.
        *   Обновить запись в `tokens.db` новым `access_token` и `expires_at`.
        *   Успешно выполнить запрос к API Директа.
    *   **Имитация невалидного refresh_token (сложнее):** Можно временно испортить `refresh_token` в БД и посмотреть, что произойдет (должна быть обработка ошибки и, возможно, редирект на логин).

**Важные Замечания для Cursor:**
*   Структурируй код с помощью функций (`get_valid_token`, `refresh_access_token`).
*   Обрабатывай все возможные ошибки: токен не найден, refresh token отсутствует, ошибка при запросе обновления, невалидный refresh token.
*   Используй `datetime.utcnow()` и `timedelta` для работы со временем.
*   Не забывай `db.session.commit()` после обновления данных в БД.
*   Логирование ошибок будет полезно для отладки.

## 4. Следующие Шаги (После выполнения текущей задачи)

*   [ ] Продумать и реализовать шифрование токенов в БД (Технический долг!).
*   [ ] Начать реализацию основного функционала MVP:
    *   [ ] Получение списка кампаний (уже есть в `/test_api_call`, можно оформить).
    *   [ ] Выбор кампании.
    *   [ ] Получение статистики по выбранной кампании (площадки, запросы и т.д.) через API Директа (Reports).
    *   [ ] Отображение статистики.
    *   [ ] Реализация функции блокировки площадок/добавления минус-слов через API Директа.

```
