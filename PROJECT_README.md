# Проект: CPC Auto Helper (MVP в Production - Веха 5)

**Версия README:** 2.0 от 28.04.25 (Обновлено по результатам экспертного анализа)

## 1. Общее Описание

**Цель Проекта:** Разработка веб-приложения (SaaS) "CPC Auto Helper" для специалистов по контекстной рекламе Яндекс.Директ, предоставляющего единую платформу для сбора, анализа и оптимизации данных из нескольких аккаунтов.

**Цель Вехи 5 (MVP в Production):** Перевести приложение на работу с **боевым API** Яндекса, используя **надежное production-окружение** (Docker, PostgreSQL). Реализовать **основную ценность MVP**: ручной сбор и отображение **агрегированной еженедельной статистики** (включая конверсии по вручную указанным целям) из **нескольких рекламных аккаунтов**, связанных с одним "Клиентом", с возможностью просмотра в улучшенном UI, **выгрузки в CSV** и базовой оптимизации (**блокировка площадок**). Обеспечить базовый уровень **безопасности** (шифрование токенов) и **надежности** (ретраи API, логирование).

**Ключевая Ценность MVP (Веха 5):** Экономия времени специалистов на ручном сборе данных из разных аккаунтов, предоставление сводной картины по кампаниям клиента за последние 4 недели в одном интерфейсе.

**Технологический стек:**
*   **Backend:** Python 3.8+, Flask, Flask-Login, Flask-SQLAlchemy, SQLAlchemy, Flask-Migrate
*   **Frontend:** HTML (Jinja2), CSS, JavaScript (базовый, без фреймворков)
*   **База данных:** **PostgreSQL** (в Docker-контейнере)
*   **Взаимодействие с API:** Requests, **Tenacity (для ретраев)**
*   **Парсинг/Генерация CSV:** Модуль `csv`, `io`
*   **Конфигурация:** Файл `.env`, `python-dotenv`
*   **Окружение:** **Docker, Docker Compose**
*   **Безопасность:** **Cryptography (для шифрования OAuth-токенов)**, Flask-Login
*   **Качество Кода:** Black, iSort, Flake8 (через pre-commit)

**Окружение Разработки:**
*   **ОС:** Windows/Linux/macOS (с установленным Docker Desktop или Docker Engine/Compose)
*   **Инструменты:** Git, Docker, Docker Compose, IDE с поддержкой Python и инструментов качества кода.

**Структура проекта:**
```
C:\python\cpc_auto_star\
├── instance/             # (Не используется с PostgreSQL в Docker)
├── app/                  # Основная папка приложения
│   ├── __init__.py       # Инициализация Flask App, Blueprints, Extensions, Logging
│   ├── models.py         # Модели SQLAlchemy (User, Client, YandexAccount, Token, Weekly*Stats)
│   ├── config.py         # Класс конфигурации, чтение из .env
│   ├── main/             # Blueprint: основные страницы (если есть, кроме отчетов/auth)
│   ├── auth/             # Blueprint: аутентификация, управление токенами, OAuth Callback
│   │   ├── routes.py
│   │   └── utils.py      # Логика OAuth, работа с токенами (включая шифрование/дешифрование)
│   ├── reports/          # Blueprint: просмотр отчетов, сбор данных, действия
│   │   ├── routes.py
│   │   └── utils.py      # Логика сбора данных, расчет метрик, работа с CSV
│   ├── api_clients/      # Клиенты для внешних API
│   │   ├── __init__.py
│   │   └── yandex_direct.py # YandexDirectClient с ретраями, универсальной функцией отчетов
│   └── templates/        # Шаблоны Jinja2 (base.html, auth/, reports/)
├── static/               # Статические файлы (css/style.css, js/main.js)
├── utils/                # Общие утилиты проекта (не относящиеся к конкретному Blueprint)
├── migrations/           # Папка Flask-Migrate (генерируемые миграции) - **НОВОЕ**
├── .env                  # Переменные окружения (Секреты, DB_URI, API ключи Prod, Ключ шифрования) - **НЕ КОММИТИТЬ**
├── .env.example          # Пример .env файла
├── .gitignore            # Исключения для Git (включая .env, venv, __pycache__, instance/)
├── requirements.txt      # Зависимости Python (закрепленные версии)
├── run.py                # Точка входа для Flask (`flask run` или `python run.py`)
├── Dockerfile            # Инструкции для сборки Docker-образа приложения - **НОВОЕ**
├── docker-compose.yml    # Конфигурация для запуска app + postgres - **НОВОЕ**
├── .pre-commit-config.yaml # Конфигурация pre-commit хуков - **НОВОЕ**
├── BUSINESS_LOGIC.md     # Описание бизнес-логики (Версия 0.3)
├── UI_DOCUMENTATION.md   # Документация по UI
├── CODING_GUIDELINES.md  # Правила написания кода (Версия 1.0)
└── PROJECT_README.md     # Этот файл (рабочий лог и план)
```

## 2. Текущий Статус (Завершение Вехи 4)

*   [x] Настроена базовая среда, OAuth (для одного аккаунта), Структура Blueprints.
*   [x] Реализовано управление сессиями через Flask-Login.
*   [x] Реализован сбор еженедельной статистики (без конверсий) в **SQLite**, запускаемый вручную для **одного** аккаунта.
*   [x] Интегрирован улучшенный UI (Jinja2, CSS, JS, Табы, Пагинация - клиентская).
*   [x] Получен доступ к **боевому API** Яндекса.
*   [x] Реализован централизованный API-клиент (`YandexDirectClient`) - базовая версия.
*   [x] Исправлена логика получения полного списка кампаний.
*   --- Ниже задачи Вехи 5 ---
*   [ ] Настроено окружение **Docker + PostgreSQL**.
*   [ ] Настроено управление миграциями БД (**Flask-Migrate**).
*   [ ] Реализовано **шифрование OAuth-токенов** в БД (`cryptography`).
*   [ ] Настроено **базовое логирование** в stdout.
*   [ ] Реализованы **повторные попытки** для API-запросов (`tenacity`).
*   [ ] Приложение переключено на работу с **боевым API** для всех операций.
*   [ ] База данных переведена на **PostgreSQL**.
*   [ ] Реализована логика **подключения нескольких аккаунтов** к "Клиенту".
*   [ ] Реализован сбор и отображение данных по **конверсиям** (с ручным вводом ID целей).
*   [ ] Реализован **агрегированный список кампаний** (из разных аккаунтов клиента).
*   [ ] Реализована **серверная сортировка** таблиц (площадки, запросы).
*   [ ] Реализована **блокировка площадок** (UI + вызов API Директа).
*   [ ] Реализована/адаптирована функция **скачивания CSV** с учетом новых данных и PostgreSQL.
*   [ ] Убраны тестовые ограничения сбора данных (`n_weeks=4`, без срезов `[:1]`).
*   [ ] Настроены и применены **pre-commit хуки** для качества кода.

## 3. ПРИОРИТЕТЫ БЕЗОПАСНОСТИ (Обязательно для Вехи 5)

Безопасность является **высшим приоритетом** из-за работы с OAuth-токенами и коммерческими данными. Следующие меры **должны быть** реализованы в Вехе 5:

1.  **Надежный `SECRET_KEY`:** Сгенерировать криптографически стойкий ключ (32 байта, `os.urandom(32)`), хранить **только** в `.env`.
2.  **Защита `.env`:** Файл `.env` **должен быть** в `.gitignore` с самого начала. Веб-сервер не должен иметь возможности его отдать.
3.  **Шифрование Токенов:**
    *   Использовать `cryptography.Fernet` для шифрования `access_token` и `refresh_token` перед сохранением в БД.
    *   Ключ для `Fernet` генерировать на основе `SECRET_KEY` (или отдельной переменной из `.env`).
    *   Хранить шифротекст в БД (поле `LargeBinary` или `Text`, если Base64).
    *   Реализовать безопасные функции `encrypt_token` / `decrypt_token`.
4.  **Безопасность Docker:**
    *   Использовать официальные `slim` образы.
    *   Запускать приложение в контейнере от **непривилегированного пользователя** (`USER nobody` или аналогичный).
    *   Не пробрасывать порт БД наружу без крайней необходимости. Сетевая изоляция контейнера БД.
    *   Использовать `volumes` для персистентности данных БД, хранить их в безопасном месте на хосте.
5.  **Разграничение Данных:** **Все** запросы к БД (SQLAlchemy) для получения токенов, статистики, клиентов, кампаний **должны** содержать фильтр по `user_id` текущего авторизованного пользователя (`current_user.id`). Провести ревью кода на предмет отсутствия этой проверки.
6.  **Защита OAuth Callback:** Использовать проверку параметра `state` для защиты от CSRF.
7.  **Безопасное Логирование:** Настроить логирование так, чтобы **не** попадали токены, API ключи, пароли и другие секреты. Уровень `INFO` или `WARNING` для production.
8.  **Проверка Зависимостей:** Закрепить версии в `requirements.txt`. Перед релизом проверить на известные уязвимости (`pip-audit` или `safety`).

## 4. ЗАДАЧА ДЛЯ РАЗРАБОТЧИКА - Веха 5: MVP в Production (Детализированный План)

**Цель:** Реализовать функционал MVP, обеспечив его работу в надежном и безопасном production-окружении на боевом API.

**Контекст для Разработчика:** Используй `BUSINESS_LOGIC.md`, `UI_DOCUMENTATION.md` и `CODING_GUIDELINES.md`. Фокусируйся на качестве, безопасности и надежности. Отмечай выполненные подзадачи в этом файле.

**Разбивка на подзадачи (с учетом анализа и приоритетов):**

**Этап 1: Фундамент и Безопасность (Приоритет 1)**

*   **Подзадача 5.1: Настройка Окружения (Docker, Postgres, Prod API)**
    *   [ ] Создать `Dockerfile` для Flask-приложения (на базе `python:3.X-slim`, установить зависимости из `requirements.txt`, настроить `WORKDIR`, `EXPOSE`, `CMD`). **Добавить создание непривилегированного пользователя и `USER` директиву.**
    *   [ ] Создать `docker-compose.yml`: сервисы `app` и `postgres`. Настроить `volumes` для данных Postgres, `env_file` для загрузки `.env`, `ports`, `networks`, `depends_on`.
    *   [ ] Адаптировать `app/config.py`: чтение `DATABASE_URI`, `SECRET_KEY`, `YANDEX_CLIENT_ID`, `YANDEX_CLIENT_SECRET`, `ENCRYPTION_KEY` (может быть = `SECRET_KEY`) из переменных окружения.
    *   [ ] Обновить `.env.example`. Создать `.env` с **реальными** данными: сгенерировать `SECRET_KEY`, указать данные для подключения к Postgres в Docker (например, `postgresql://user:password@postgres:5432/dbname`), указать Client ID/Secret **боевого** приложения Яндекса.
    *   [ ] **Добавить `.env` в `.gitignore` СРАЗУ ЖЕ.**
    *   [ ] Запустить проект: `docker-compose up --build`.
    *   **Проверка:** Приложение стартует, подключается к Postgres, логи видны (`docker-compose logs app`). Пройти OAuth флоу с **боевым Яндексом**.

*   **Подзадача 5.2: Управление Схемой БД (Flask-Migrate)**
    *   [ ] Добавить `Flask-Migrate` в `requirements.txt` и `app/__init__.py`.
    *   [ ] **Внутри контейнера `app`** (`docker-compose exec app bash`):
        *   [ ] Инициализировать: `flask db init` (один раз).
        *   [ ] Создать модели в `app/models.py`: `User`, `Client` (новая сущность!), `YandexAccount` (связь Client <-> Яндекс Логин), `Token` (связь с `YandexAccount`), `WeeklyCampaignStat`, `WeeklyPlacementStat` и т.д. (Добавить поля `user_id`, `client_id`, `yandex_account_login` где нужно).
        *   [ ] Создать начальную миграцию: `flask db migrate -m "Initial database schema"`
        *   [ ] Применить миграцию: `flask db upgrade`
    *   **Проверка:** Таблицы созданы в PostgreSQL. Папка `migrations` появилась и добавлена в Git.

*   **Подзадача 5.3: Безопасность Токенов и Базовое Логирование**
    *   [ ] Добавить `cryptography` в `requirements.txt`.
    *   [ ] В `app/auth/utils.py` (или `app/utils.py`): реализовать функции `encrypt_data(data: str) -> bytes` и `decrypt_data(encrypted_data: bytes) -> str`, используя `Fernet` и ключ из `config`.
    *   [ ] Модифицировать модель `Token`: поля `access_token` и `refresh_token` сделать типа `LargeBinary`.
    *   [ ] Обновить логику сохранения токенов в `app/auth/routes.py` (или где происходит callback): шифровать токены перед записью в `db.session`.
    *   [ ] Обновить логику получения токенов (например, в `YandexDirectClient` или `app/auth/utils.py`): получать зашифрованный токен из БД и расшифровывать его перед использованием. **Строго проверять `user_id`!**
    *   [ ] Создать и применить миграцию Flask-Migrate для изменения типа полей токенов.
    *   [ ] Настроить базовое логирование в `app/__init__.py`: уровень `INFO`, вывод в `stdout` (чтобы видеть в `docker-compose logs`). Использовать стандартный `logging`. Заменить все `print()` на `logger.debug()`, `logger.info()` и т.д. **Убедиться, что секреты не логируются.**
    *   **Проверка:** OAuth флоу работает. Токены в БД зашифрованы (нечитаемы). Расшифровка работает, API Директа вызывается успешно. Логи информативны и безопасны.

**Этап 2: Основной Функционал MVP (Приоритет 2)**

*   **Подзадача 5.4: Подключение Нескольких Аккаунтов и Сбор Данных**
    *   [ ] Реализовать UI и логику для создания сущности "Клиент" в сервисе (привязан к `current_user`).
    *   [ ] Реализовать UI и логику для подключения **нескольких** рекламных аккаунтов Яндекс.Директ к **выбранному** "Клиенту". Это потребует инициировать OAuth флоу для каждого нового аккаунта и сохранять его токен (`Token`) с привязкой к `YandexAccount`, который связан с `Client` и `User`. Продумать UX, чтобы пользователь не запутался.
    *   [ ] Адаптировать `YandexDirectClient`: он должен уметь работать с конкретным токеном (передавать `access_token` при инициализации или в каждом методе).
    *   [ ] Адаптировать логику ручного сбора данных (`app/reports/routes.py` и `utils.py`):
        *   Пользователь выбирает "Клиента".
        *   Система получает все активные `YandexAccount`, связанные с этим клиентом.
        *   Для **каждого** аккаунта: получает действительный (расшифрованный) токен, вызывает `YandexDirectClient` для получения данных по кампаниям и срезам (площадки, запросы, регионы и т.д.) за последние 4 недели (параметр `n_weeks=4`).
        *   Данные сохраняются в соответствующие таблицы `Weekly*Stat` в PostgreSQL с указанием `user_id`, `client_id`, `yandex_account_login`.
        *   **Обеспечить обработку ошибок на уровне аккаунта:** если сбор для одного аккаунта упал, продолжать для других, логировать ошибку.
    *   **Проверка:** Можно создать клиента, подключить к нему 2+ аккаунта Яндекса. Запуск сбора данных для клиента собирает статистику из всех подключенных аккаунтов и сохраняет в БД.

*   **Подзадача 5.5: Реализация Сбора и Отображения Конверсий**
    *   [ ] Добавить в UI (настройки клиента или глобальные настройки) поле для **ручного ввода ID целей Метрики** (список через запятую). Сохранять эти ID (например, в модели `Client` или `User`). *Упрощение для MVP.*
    *   [ ] Модифицировать запросы к API Reports (`YandexDirectClient`): добавить параметр `Goals` со списком ID целей, полученных из настроек. Запрашивать поля `Conversions` (и, возможно, `CostPerConversion`, `Revenue` если нужно).
    *   [ ] Адаптировать модели `Weekly*Stat`: добавить поля для хранения суммы конверсий по указанным целям (например, `conversions: int`). Создать и применить миграцию.
    *   [ ] Адаптировать логику парсинга отчетов API и записи в БД.
    *   [ ] Адаптировать UI (`reports/campaign_list.html`, `reports/campaign_detail.html`):
        *   Отображать столбец "Конверсии".
        *   **Рассчитывать на лету** и отображать CR (%) и CPA (руб.) - **обработать деление на ноль!** (отображать 0 или 'N/A').
    *   **Проверка:** После ввода ID целей и запуска сбора, в интерфейсе отображаются конверсии, CR, CPA. Расчеты корректны, включая случаи с 0 кликов/конверсий.

*   **Подзадача 5.6: Агрегированный Список Кампаний и Детализация**
    *   [ ] Реализовать роут и шаблон (`reports/campaign_list.html`) для отображения **агрегированного списка кампаний**:
        *   При выборе "Клиента", сделать запрос к БД для получения **всех** `WeeklyCampaignStat` за последнюю неделю, относящихся к этому `client_id` (из разных `yandex_account_login`).
        *   Отобразить список кампаний с основными метриками (включая конверсии, CR, CPA).
        *   **Важно:** Добавить в таблицу столбец или индикатор, показывающий, к какому `yandex_account_login` относится кампания, чтобы избежать путаницы.
    *   [ ] Реализовать роут `view_campaign_detail`: при клике на кампанию из списка, отображать детальную статистику **только по этой кампании** (из ее родного аккаунта) за 4 недели, включая срезы (площадки, запросы и т.д.).
    *   **Проверка:** Список кампаний показывает данные из всех аккаунтов клиента. Детализация показывает данные конкретной кампании.

**Этап 3: Улучшения и Завершение (Приоритет 3)**

*   **Подзадача 5.7: Надежность API и Серверная Сортировка**
    *   [ ] Добавить `tenacity` в `requirements.txt`.
    *   [ ] В `YandexDirectClient._make_request` (или аналогичный метод): обернуть вызовы `requests.post/get` декоратором `@retry` из `tenacity`. Настроить ретраи на временные ошибки (5xx, 429, Timeout, ConnectionError) с экспоненциальной задержкой (`wait=wait_exponential(...)`) и ограничением числа попыток (`stop=stop_after_attempt(3)`). **Логировать каждую попытку ретрая.**
    *   [ ] Реализовать **серверную сортировку** для таблиц в `campaign_detail.html` (Площадки, Запросы). Добавить параметры `sort_by`, `sort_order` в URL/запрос, использовать `SQLAlchemy.orm.Query.order_by()` в роуте. Обновить UI для отображения направления сортировки.
    *   **Проверка:** Сбор данных более устойчив к сбоям API. Таблицы на странице детализации сортируются по клику на заголовок (запрос уходит на сервер).

*   **Подзадача 5.8: Реализация Блокировки Площадок**
    *   [ ] В `campaign_detail.html`, в табе "Площадки": добавить чекбоксы для выбора площадок и кнопку "Заблокировать выбранные". Использовать `confirm()` в JS для подтверждения.
    *   [ ] Реализовать POST-роут (`/campaign/<campaign_id>/block_placements`). Он должен:
        *   Принять список ID площадок.
        *   Получить `access_token` для аккаунта, к которому принадлежит кампания.
        *   **Определить тип кампании** (может потребоваться доп. запрос к API), т.к. API для блокировки может отличаться (например, `adgroups.update` для ТГО с полем `NegativeSites`, или `campaigns.update` для РСЯ). *Уточнить по документации API Директа!*
        *   Вызвать соответствующий метод API Директа через `YandexDirectClient` для добавления площадок в список запрещенных.
        *   Использовать `flash()` для сообщения об успехе или ошибке.
    *   **Проверка:** Выбранные площадки блокируются в интерфейсе Яндекс.Директа. Обрабатываются ошибки API.

*   **Подзадача 5.9: Реализация Скачивания CSV**
    *   [ ] Реализовать/адаптировать роут `download_csv` (например, `/client/<client_id>/download_csv` или `/campaign/<campaign_id>/download_csv`).
    *   [ ] Логика: получить данные из PostgreSQL (агрегированные по клиенту или детальные по кампании/срезам, в зависимости от точки вызова). Рассчитать метрики (CR, CPA), обработать деление на 0.
    *   [ ] Сформировать CSV файл (использовать `io.StringIO`, модуль `csv`). Указать **кодировку UTF-8**. Обработать спецсимволы в данных.
    *   [ ] Вернуть файл пользователю как `Response` с правильными заголовками (`Content-Disposition`, `Content-Type`).
    *   **Проверка:** Скачивается корректный CSV файл, читаемый в Excel/Google Sheets, с правильными данными и заголовками.

*   **Подзадача 5.10: Качество Кода и Финальная Очистка**
    *   [ ] Настроить pre-commit: `pip install pre-commit`, создать `.pre-commit-config.yaml` с хуками `black`, `isort`, `flake8`. Запустить `pre-commit install`.
    *   [ ] Применить форматирование и линтинг ко всей кодовой базе: `pre-commit run --all-files`. Исправить все ошибки.
    *   [ ] Пройтись по коду: убрать все тестовые ограничения (`[:1]`, лимиты на количество кампаний/аккаунтов), удалить закомментированный код, добавить недостающие docstrings и type hints (согласно `CODING_GUIDELINES.md`).
    *   [ ] Провести финальное **ручное тестирование** всего функционала MVP в Docker-окружении на Production API, обращая внимание на пункты из раздела "Потенциальные Ловушки".
    *   **Проверка:** Код чистый, соответствует гайдлайнам. MVP работает стабильно и выполняет заявленные функции.

## 5. КЛЮЧЕВЫЕ ПРОДУКТОВЫЕ РИСКИ MVP (Веха 5)

*   **Ручной Запуск Сбора Данных:** Основной барьер для регулярного использования. Пользователям нужно будет не забывать заходить и нажимать кнопку. *Смягчение:* Четко позиционировать как MVP, собирать фидбек о необходимости автоматизации (-> Веха 6).
*   **Недельная Гранулярность Данных:** Снижает оперативность и точность анализа для опытных специалистов. Может скрывать важные дневные флуктуации. *Смягчение:* Принять как ограничение MVP, рассмотреть переход на дневную в Вехе 6 (см. Стратегические Замечания).
*   **Ручной Ввод ID Целей:** Неудобно, источник ошибок, барьер для пользователей, не знающих ID. *Смягчение:* Сделать UI максимально понятным, запланировать авто-получение целей как приоритет после MVP.
*   **Отсутствие "Интеллекта":** MVP не дает подсказок и рекомендаций (это Веха 7+). Пользователи могут ожидать большего. *Смягчение:* Четкое позиционирование MVP как "агрегатора данных", а не "оптимизатора".

## 6. ПОТЕНЦИАЛЬНЫЕ ЛОВУШКИ И ТОЧКИ ТЕСТИРОВАНИЯ (Фокус для QA)

*   **Сбои Сбора Данных:** Что происходит при ошибках API, сети, парсинга во время ручного сбора? Консистентность данных? Сообщения об ошибках? Возможность перезапуска?
*   **ID Целей:** Ввод несуществующих, неправильных ID, ID от чужих счетчиков. Обработка ошибок API.
*   **Расчет Метрик:** Деление на ноль (CTR, CPC, CR, CPA). Отображение `0` или `N/A`.
*   **Логика Недель:** Как определяется "неделя"? Как обрабатываются неполные недели?
*   **API Блокировки Площадок:** Корректность определения типа кампании и вызова нужного метода API. Повторная блокировка. Лимиты API.
*   **Генерация CSV:** Кодировка (UTF-8?), разделители, обработка кавычек, запятых, переносов строк в данных. Производительность для больших объемов.
*   **OAuth Флоу для Нескольких Аккаунтов:** Юзабилити, понятность привязки аккаунта к клиенту.
*   **Смена `SECRET_KEY`:** Как поведет себя система? (В MVP не должно меняться, но иметь в виду).
*   **Права Доступа:** Попытки получить доступ к чужим данным (клиенты, кампании, токены) через прямые запросы/подмену ID.
*   **Производительность UI:** Сортировка (серверная - ОК), но поиск/фильтры в таблицах - клиентские или серверные? Если клиентские - проверить на >1000 строк.

## 7. СТРАТЕГИЧЕСКИЕ ЗАМЕЧАНИЯ И ТЕХНИЧЕСКИЙ ДОЛГ

*   **PostgreSQL vs ClickHouse:** Для MVP Postgres - ОК. Но для будущей аналитики и AI, ClickHouse может быть эффективнее. **Действие:** Проектировать схему `Weekly*Stat` максимально просто (без сложных JSON, простые типы), чтобы упростить возможную миграцию. Добавить необходимые **индексы** в Postgres сразу (`user_id`, `client_id`, `yandex_account_login`, `campaign_id`, `date`).
*   **Недельная vs Дневная Гранулярность:** Недельная гранулярность - **значительный технический долг** для будущего AI-анализа. **Действие:** Серьезно рассмотреть переход на **дневное** хранение данных в **Вехе 6**. Оценить влияние на стоимость хранения и производительность сбора.
*   **Хранение Агрегатов:** Сейчас храним только агрегированные данные. Потеряна возможность более глубокого анализа (например, по часам). **Действие:** Принять как ограничение MVP/Вехи 6. Если понадобится глубже - потребует пересмотра сбора/хранения.
*   **Архитектура для Фонов (Веха 6):** Автоматический сбор потребует Celery/RQ. **Действие:** В Вехе 5 выносить логику сбора данных (`app/reports/utils.py`) в функции, максимально независимые от Flask request контекста.
*   **Масштабируемость Сбора:** Продумать обработку лимитов API Директа при росте числа пользователей/аккаунтов.
*   **Мониторинг:** Заложить основы: структурированное логирование, возможно, базовые метрики (время выполнения сбора данных).

## 8. Логика Работы с Документацией

*   Обновлять секцию "Текущий Статус" этого файла (`PROJECT_README.md`) после **каждой выполненной подзадачи**, отмечая ее как `[x]`.
*   При возникновении проблем или изменении решений - фиксировать их здесь.
*   **В конце Вехи 5:** Финализировать этот документ, обновить `BUSINESS_LOGIC.md` (если были отклонения), подготовить план на Веху 6.

## 9. Следующие Шаги (После Вехи 5 - MVP)

*   **Веха 6: Автоматизация, Улучшения, Подготовка к AI**
    *   **Приоритет 1:** Автоматический еженедельный (или ежедневный?) сбор данных (Celery/RQ).
    *   **Приоритет 2:** Переход на **дневную гранулярность** данных (требует решения и оценки).
    *   **Приоритет 3:** Автоматическое получение списка целей из Яндекс.Метрики.
    *   Реализация ввода/хранения/визуализации KPI.
    *   Улучшения UX (фильтры, графики?).
    *   Оптимизация производительности (если нужно).
*   **Веха 7: Интеграция AI (Шаг 1 - Hi-Level Анализ)**
*   **Веха 8: Интеграция AI (Шаг 2 - Анализ по Срезам) + Минусация**
*   **Веха 9: Контроль Бюджета и Другие Фичи**

---