# Проект: CPC Auto Helper (Стартовый этап MVP)

## 1. Общее Описание

**Цель:** Разработка веб-приложения (SaaS) для помощи специалистам по контекстной рекламе Яндекс.Директ. Сервис должен автоматизировать рутинные задачи сбора/анализа статистики и предоставлять рекомендации.

**Технологический стек:**
*   **Backend:** Python 3.x, Flask
*   **Структура:** Flask Blueprints
*   **Работа с БД:** Flask-SQLAlchemy (ORM), SQLAlchemy
*   **База данных:** SQLite (файл `tokens.db`)
*   **HTTP Запросы:** Requests
*   **Парсинг данных:** Модуль `csv` Python
*   **Конфигурация:** python-dotenv
*   **Frontend:** Простейший HTML, генерируемый напрямую из Flask.

**Окружение Разработки:**
*   **ОС:** Windows 10/11
*   **Python:** Версия 3.x (установлен)
*   **Виртуальное окружение:** Используется `venv`
*   **Менеджер пакетов:** `pip`

**Структура проекта:**
```
C:\python\cpc_auto_star\
├── venv\                 # Виртуальное окружение
├── instance/             # Папка Flask для instance-файлов
│   └── tokens.db         # Файл базы данных SQLite - СОЗДАН
├── app/                  # Основная папка приложения
│   ├── __init__.py       # Инициализация приложения, регистрация Blueprints
│   ├── models.py         # Модель SQLAlchemy (Token)
│   ├── auth/             # Blueprint 'auth' (аутентификация)
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   └── utils.py      # Функции работы с токенами
│   ├── reports/          # Blueprint 'reports' (отчеты и действия)
│   │   ├── __init__.py
│   │   ├── routes.py     # Роуты для /campaigns, /campaign/<id>/platforms etc.
│   │   └── utils.py      # Функции для работы с API Reports
│   └── templates/        # (Опционально) Папка для HTML шаблонов
├── utils/                # Папка для утилитарных скриптов
│   └── create_test_campaigns.py # Скрипт для создания тестовых кампаний
├── .env                  # Ключи API Яндекса
├── .gitignore            # Правила игнорирования Git
├── requirements.txt      # Список зависимостей
├── run.py                # Файл для запуска приложения
└── PROJECT_README.md     # Этот файл
```

## 2. Текущий Статус (Что уже сделано)

*   [x] Настроена среда разработки (venv, зависимости).
*   [x] Реализован полный цикл Яндекс OAuth с хранением токенов в БД SQLite и автоматическим обновлением.
*   [x] Код реорганизован с использованием Flask Blueprints (`auth`, `reports`).
*   [x] Реализован вывод списка кампаний пользователя (`/reports/campaigns`).
*   [x] Реализован полный цикл получения и отображения отчета по площадкам (используя `CUSTOM_REPORT`) для выбранной кампании.
*   [ ] Создана утилита для генерации тестовых кампаний (РСЯ, ЕПК) через API.
*   [ ] Реализован отчет по поисковым запросам (`SEARCH_QUERY_PERFORMANCE_REPORT`).
*   [ ] Реализована функция блокировки площадок РСЯ через API.
*   [ ] Реализована функция добавления минус-слов (на уровень кампании) через API.
*   [ ] Добавлены элементы UI (чекбоксы, кнопки) для выполнения действий с площадками/запросами.

## 3. ЗАДАЧА ДЛЯ CURSOR - Шаг 4: Утилита для Создания Тестовых Кампаний

**Цель:** Создать отдельный Python-скрипт (`utils/create_test_campaigns.py`), который позволит программно создавать различные типы тестовых кампаний в песочнице Яндекс.Директ через API v5, используя точные параметры и структуры запросов.

**Требования к скрипту `utils/create_test_campaigns.py`:**

1.  **Независимость и Запуск:** Скрипт запускается из командной строки (`python utils/create_test_campaigns.py`).
2.  **Аутентификация:**
    *   Скрипт должен получать действительный `access_token` и `client_login` для работы с Песочницей.
    *   **Реализация:** Использовать существующую БД `tokens.db` и функцию `get_valid_token` из `app.auth.utils`. Для этого потребуется создать временный контекст приложения Flask внутри скрипта (`with app.app_context():`) или передать необходимые объекты. `client_login` тестового аккаунта можно временно захардкодить в скрипте или передавать аргументом.
3.  **Общая функция для запросов:** Использовать базовую функцию `make_api_request(url, payload)` (из твоего справочника) для отправки запросов и базовой обработки ответов/ошибок.
4.  **Функция `create_text_campaign_rsya(access_token, client_login, name_prefix="Тест РСЯ ")`:**
    *   **Создание Кампании:**
        *   URL: `https://api-sandbox.direct.yandex.com/json/v5/campaigns`
        *   Метод: `add`
        *   Структура `CampaignAddItem` в `params`:
            *   `Name`: f"{name_prefix}{int(time.time())}" (для уникальности)
            *   `StartDate`: (сегодняшняя или завтрашняя дата в формате YYYY-MM-DD)
            *   `TextCampaign`:
                *   `BiddingStrategy`:
                    *   `Search`: `{ "BiddingStrategyType": "SERVING_OFF" }` (Отключаем поиск)
                    *   `Network`: `{ "BiddingStrategyType": "NETWORK_DEFAULT" }` (Стратегия по умолчанию для сетей)
                *   `CounterIds`: `{ "Items": [ID_СЧЕТЧИКА_ПЕСОЧНИЦЫ] }` (Заменить на реальный ID счетчика из Песочницы, если есть)
                *   (Опционально) `Settings`: Можно добавить настройки, специфичные для РСЯ, например, отключение расширенного геотаргетинга. Проверить доступность в методе `add`.
        *   Получить `CampaignId` из успешного ответа.
    *   **Создание Группы Объявлений:**
        *   URL: `https://api-sandbox.direct.yandex.com/json/v5/adgroups`
        *   Метод: `add`
        *   Структура `AdGroupAddItem` в `params`:
            *   `Name`: "Тестовая группа РСЯ"
            *   `CampaignId`: (ID, полученный на шаге выше)
            *   `RegionIds`: `[1]` (Россия) или другой релевантный регион.
            *   `NegativeKeywords`: `{ "Items": ["бесплатно", "скачать"] }` (Пример)
        *   Получить `AdGroupId` из успешного ответа.
    *   **Создание Объявления:**
        *   URL: `https://api-sandbox.direct.yandex.com/json/v5/ads`
        *   Метод: `add`
        *   Структура `AdAddItem` в `params`:
            *   `AdGroupId`: (ID, полученный на шаге выше)
            *   `TextAd`:
                *   `Title`: "Тестовое объявление РСЯ"
                *   `Text`: "Это текст тестового объявления для проверки работы с площадками в РСЯ."
                *   `Href`: "https://example-sandbox.com"
        *   Получить `AdId` из успешного ответа.
    *   **Создание Ключевого Слова (для активации):**
        *   URL: `https://api-sandbox.direct.yandex.com/json/v5/keywords`
        *   Метод: `add`
        *   Структура `KeywordAddItem` в `params`:
            *   `Keyword`: "тестовый ключ рся"
            *   `AdGroupId`: (ID группы)
    *   **Возврат:** Функция должна вернуть `CampaignId` созданной кампании.
5.  **Функция `create_unified_performance_campaign(access_token, client_login, name_prefix="Тест ЕПК ")` (Опционально, для будущего развития):**
    *   **Создание Кампании:**
        *   URL: `https://api-sandbox.direct.yandex.com/json/v501/campaigns` **(v501!)**
        *   Метод: `add`
        *   Структура `CampaignAddItem` в `params`:
            *   `Name`: f"{name_prefix}{int(time.time())}"
            *   `StartDate`: (дата)
            *   `UnifiedCampaign`:
                *   `CounterIds`: `{ "Items": [ID_СЧЕТЧИКА_ПЕСОЧНИЦЫ] }` (**Обязательно**)
                *   `BiddingStrategy`: (Выбрать допустимую стратегию для ЕПК, например, `AVERAGE_CPA`)
                *   Учесть возможную необходимость указания `PackageStrategy` и других специфичных полей.
        *   Получить `CampaignId`.
    *   **(Дальнейшие шаги для ЕПК потребуют добавления групп, фидов и т.д., что выходит за рамки текущей задачи).**
    *   **Возврат:** Функция должна вернуть `CampaignId`.
6.  **Основная логика скрипта (`if __name__ == "__main__":`)**
    *   Настроить импорты (`requests`, `json`, `time`, и необходимые компоненты из `app` для получения токена).
    *   Определить `CLIENT_LOGIN_TO_USE` (захардкодить или из аргумента).
    *   Создать экземпляр `app` из `app/__init__.py` для доступа к контексту.
    *   Внутри `with app.app_context():` получить `access_token` через `get_valid_token(CLIENT_LOGIN_TO_USE)`.
    *   Если токен получен:
        *   Вызвать `create_text_campaign_rsya` 1-2 раза.
        *   (Опционально) Вызвать `create_unified_performance_campaign`.
        *   Вывести результаты (ID созданных кампаний) в консоль.
    *   Обработать случай, если токен не получен.

**Важные Замечания для Cursor:**
*   Используй точные URL эндпоинтов (v5 и v501) и методы (`add`).
*   Точно следуй структурам запросов (`CampaignAddItem`, `TextCampaign`, `UnifiedCampaign`, `AdGroupAddItem`, `AdAddItem`, `KeywordAddItem`), указанным в документации API v5 для Песочницы. Обрати внимание на обязательные поля.
*   Реализуй последовательное создание: Кампания -> Группа -> Объявление -> Ключ. Используй ID, полученные на предыдущих шагах.
*   Тщательно обрабатывай ошибки от *каждого* вызова API, используя функцию `make_api_request`.
*   Удели внимание корректной настройке контекста Flask (`app.app_context()`) при использовании `get_valid_token` из основного приложения.
*   Импортируй `datetime`, `time`, `requests`, `json` и нужные компоненты из `app`.

## 4. Следующий Шаг (После Шага 4) - ЗАДАЧА 5: Отчет по Запросам и Реализация Действий

*   [ ] Реализовать отчет по поисковым запросам (`SEARCH_QUERY_PERFORMANCE_REPORT`).
*   [ ] Добавить UI элементы (чекбоксы, кнопки) для выбора площадок и запросов.
*   [ ] Реализовать функцию и роут для блокировки выбранных площадок (через API `AdGroups.set`, используя созданные РСЯ-кампании для теста).
*   [ ] Реализовать функцию и роут для добавления выбранных поисковых запросов в минус-слова кампании (через API `Campaigns.set` или `AdGroups.set`).
*   [ ] Обеспечить обратную связь пользователю о результате выполнения действий.

## 5. Дальнейшие Шаги (Пост-MVP)

*   [ ] Продумать и реализовать шифрование токенов в БД.
*   [ ] Заменить `time.sleep()` на фоновые задачи (Celery/RQ).
*   [ ] Улучшить UI/UX (шаблонизатор Jinja2, CSS).
*   [ ] Добавить больше типов отчетов и аналитики.
*   [ ] Реализовать поддержку других типов кампаний.

```

Теперь инструкции для Cursor стали гораздо конкретнее, ссылаясь на точные структуры и параметры API, которые ты изучил. Это должно значительно повысить качество генерируемого кода для утилиты.