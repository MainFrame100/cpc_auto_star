# Проект: CPC Auto Helper (MVP в Production - Веха 5)

**Версия README:** 2.0 от 28.04.25 (Обновлено по результатам экспертного анализа)

## 1. Общее Описание

**Цель Проекта:** Разработка веб-приложения (SaaS) "CPC Auto Helper" для специалистов по контекстной рекламе Яндекс.Директ, предоставляющего единую платформу для сбора, анализа и оптимизации данных из нескольких аккаунтов.

**Цель Вехи 5 (MVP в Production):** Перевести приложение на работу с **боевым API** Яндекса, используя **надежное production-окружение** (Docker, PostgreSQL). Реализовать **основную ценность MVP**: ручной сбор и отображение **агрегированной еженедельной статистики** (включая конверсии по вручную указанным целям) из **нескольких рекламных аккаунтов**, связанных с одним "Клиентом", с возможностью просмотра в улучшенном UI, **выгрузки в CSV** и базовой оптимизации (**блокировка площадок**). Обеспечить базовый уровень **безопасности** (шифрование токенов) и **надежности** (ретраи API, логирование).

**Ключевая Ценность MVP (Веха 5):** Экономия времени специалистов на ручном сборе данных из разных аккаунтов, предоставление сводной картины по кампаниям клиента за последние 4 недели в одном интерфейсе.

**Технологический стек:**
*   **Backend:** Python 3.8+, Flask, Flask-Login, Flask-SQLAlchemy, SQLAlchemy, Flask-Migrate
*   **Frontend:** HTML (Jinja2), CSS, JavaScript (базовый, без фреймворков)
*   **База данных:** **PostgreSQL** (в Docker-контейнере)
*   **Взаимодействие с API:** Requests, **Tenacity (для ретраев)**
*   **Парсинг/Генерация CSV:** Модуль `csv`, `io`
*   **Конфигурация:** Файл `.env`, `python-dotenv`
*   **Окружение:** **Docker, Docker Compose**
*   **Безопасность:** **Cryptography (для шифрования OAuth-токенов)**, Flask-Login
*   **Качество Кода:** Black, iSort, Flake8 (через pre-commit)

**Окружение Разработки:**
*   **ОС:** Windows/Linux/macOS (с установленным Docker Desktop или Docker Engine/Compose)
*   **Инструменты:** Git, Docker, Docker Compose, IDE с поддержкой Python и инструментов качества кода.

**Структура проекта:**
```
C:\python\cpc_auto_star\
├── instance/             # (Не используется с PostgreSQL в Docker)
├── app/                  # Основная папка приложения
│   ├── __init__.py       # Инициализация Flask App, Blueprints, Extensions, Logging
│   ├── models.py         # Модели SQLAlchemy (User, Client, YandexAccount, Token, Weekly*Stats)
│   ├── config.py         # Класс конфигурации, чтение из .env
│   ├── main/             # Blueprint: основные страницы (если есть, кроме отчетов/auth)
│   ├── auth/             # Blueprint: аутентификация, управление токенами, OAuth Callback
│   │   ├── routes.py
│   │   └── utils.py      # Логика OAuth, работа с токенами (включая шифрование/дешифрование)
│   ├── reports/          # Blueprint: просмотр отчетов, сбор данных, действия
│   │   ├── routes.py
│   │   └── utils.py      # Логика сбора данных, расчет метрик, работа с CSV
│   ├── api_clients/      # Клиенты для внешних API
│   │   ├── __init__.py
│   │   └── yandex_direct.py # YandexDirectClient с ретраями, универсальной функцией отчетов
│   └── templates/        # Шаблоны Jinja2 (base.html, auth/, reports/)
├── static/               # Статические файлы (css/style.css, js/main.js)
├── utils/                # Общие утилиты проекта (не относящиеся к конкретному Blueprint)
├── migrations/           # Папка Flask-Migrate (генерируемые миграции) - **НОВОЕ**
├── .env                  # Переменные окружения (Секреты, DB_URI, API ключи Prod, Ключ шифрования) - **НЕ КОММИТИТЬ**
├── .env.example          # Пример .env файла
├── .gitignore            # Исключения для Git (включая .env, venv, __pycache__, instance/)
├── requirements.txt      # Зависимости Python (закрепленные версии)
├── run.py                # Точка входа для Flask (`flask run` или `python run.py`)
├── Dockerfile            # Инструкции для сборки Docker-образа приложения - **НОВОЕ**
├── docker-compose.yml    # Конфигурация для запуска app + postgres - **НОВОЕ**
├── .pre-commit-config.yaml # Конфигурация pre-commit хуков - **НОВОЕ**
├── BUSINESS_LOGIC.md     # Описание бизнес-логики (Версия 0.3)
├── UI_DOCUMENTATION.md   # Документация по UI
├── CODING_GUIDELINES.md  # Правила написания кода (Версия 1.0)
└── PROJECT_README.md     # Этот файл (рабочий лог и план)
```

## 2. Текущий Статус (Завершение Этапа 1 Вехи 5)

*   [x] Настроено окружение **Docker + PostgreSQL**.
*   [x] Настроено управление миграциями БД (**Flask-Migrate**).
*   [x] Реализовано **шифрование OAuth-токенов** в БД (`cryptography`).
*   [x] Настроено **базовое логирование** в stdout.
*   --- Ниже задачи следующих этапов Вехи 5 ---
*   [ ] Реализованы **повторные попытки** для API-запросов (`tenacity`).
*   [ ] Реализована логика **подключения нескольких аккаунтов** к "Клиенту".
*   [ ] Реализован **единый, двухэтапный процесс сбора данных** (включая список кампаний через Reports API и детальную статистику).
*   [ ] Реализован сбор и отображение данных по **конверсиям** (с ручным вводом ID целей).
*   [ ] Реализован **агрегированный список кампаний**, читающий данные из **локальной БД** после обновления.
*   [ ] Реализована **серверная сортировка** таблиц (площадки, запросы).
*   [ ] Реализована **блокировка площадок** (UI + вызов API Директа).
*   [ ] Реализована/адаптирована функция **скачивания CSV** с учетом новых данных и PostgreSQL.
*   [ ] Убраны тестовые ограничения сбора данных (`n_weeks=4`, без срезов `[:1]`).
*   [ ] Настроены и применены **pre-commit хуки** для качества кода.

## 3. ПРИОРИТЕТЫ БЕЗОПАСНОСТИ (Обязательно для Вехи 5)

Безопасность является **высшим приоритетом** из-за работы с OAuth-токенами и коммерческими данными. Следующие меры **должны быть** реализованы в Вехе 5:

1.  **Надежный `SECRET_KEY`:** Сгенерировать криптографически стойкий ключ (32 байта, `os.urandom(32)`), хранить **только** в `.env`.
2.  **Защита `.env`:** Файл `.env` **должен быть** в `.gitignore` с самого начала. Веб-сервер не должен иметь возможности его отдать.
3.  **Шифрование Токенов:**
    *   Использовать `cryptography.Fernet` для шифрования `access_token` и `refresh_token` перед сохранением в БД.
    *   Ключ для `Fernet` генерировать на основе `SECRET_KEY` (или отдельной переменной из `.env`).
    *   Хранить шифротекст в БД (поле `LargeBinary` или `Text`, если Base64).
    *   Реализовать безопасные функции `encrypt_token` / `decrypt_token`.
4.  **Безопасность Docker:**
    *   Использовать официальные `slim` образы.
    *   Запускать приложение в контейнере от **непривилегированного пользователя** (`USER nobody` или аналогичный).
    *   Не пробрасывать порт БД наружу без крайней необходимости. Сетевая изоляция контейнера БД.
    *   Использовать `volumes` для персистентности данных БД, хранить их в безопасном месте на хосте.
5.  **Разграничение Данных:** **Все** запросы к БД (SQLAlchemy) для получения токенов, статистики, клиентов, кампаний **должны** содержать фильтр по `user_id` текущего авторизованного пользователя (`current_user.id`). Провести ревью кода на предмет отсутствия этой проверки.
6.  **Защита OAuth Callback:** Использовать проверку параметра `state` для защиты от CSRF.
7.  **Безопасное Логирование:** Настроить логирование так, чтобы **не** попадали токены, API ключи, пароли и другие секреты. Уровень `INFO` или `WARNING` для production.
8.  **Проверка Зависимостей:** Закрепить версии в `requirements.txt`. Перед релизом проверить на известные уязвимости (`pip-audit` или `safety`).

## 4. ЗАДАЧА ДЛЯ РАЗРАБОТЧИКА - Веха 5: MVP в Production (Детализированный План)

**Цель:** Реализовать функционал MVP, обеспечив его работу в надежном и безопасном production-окружении на боевом API. **Обновление данных происходит единым процессом.**

**Контекст для Разработчика:** Используй `BUSINESS_LOGIC.md`, `UI_DOCUMENTATION.md` и `CODING_GUIDELINES.md`. Фокусируйся на качестве, безопасности и надежности. Отмечай выполненные подзадачи в этом файле.

**Разбивка на подзадачи (с учетом анализа и приоритетов):**

**Этап 1: Фундамент и Безопасность (Приоритет 1) - ЗАВЕРШЕНО**
*   **Подзадача 5.1:** Настройка Окружения (Docker, Postgres, Prod API) - [x]
*   **Подзадача 5.2:** Управление Схемой БД (Flask-Migrate) - [x]
*   **Подзадача 5.3:** Безопасность Токенов и Базовое Логирование - [x]

**Этап 2: Основной Функционал MVP (Приоритет 2)**

*   **Подзадача 5.4: Подключение Нескольких Аккаунтов**
    *   [ ] Реализовать UI и логику для создания сущности "Клиент".
    *   [ ] Реализовать UI и логику для подключения **нескольких** рекламных аккаунтов Яндекс.Директ к **выбранному** "Клиенту" (OAuth флоу для каждого, сохранение токенов с привязкой к Client/YandexAccount/User). Продумать UX.
    *   [ ] Адаптировать `YandexDirectClient`: должен уметь работать с конкретным (расшифрованным) токеном.
    *   **Проверка:** Можно создать клиента, подключить 2+ аккаунта Яндекса. Токены сохраняются и могут быть получены для дальнейшей работы.

*   **Подзадача 5.5: Единый Процесс Сбора Данных (2 этапа)**
    *   [ ] Определить **единую точку входа** (роут + функция-оркестратор, например, `/reports/client/<client_id>/update_stats`) для запуска **всего** процесса обновления данных для клиента.
    *   [ ] **Реализовать Шаг 1: Быстрое Обновление Списка Кампаний:**
        *   Функция запрашивает отчет `CAMPAIGN_PERFORMANCE_REPORT` для каждого аккаунта клиента.
        *   `ReportDefinition`: Период - **последние 4 недели** , Срезы - `CampaignId`, `CampaignName`, `CampaignType`, Метрики - **на этом этапе без конверсия**.
        *   Парсинг отчета.
        *   **`UPSERT`** в `WeeklyCampaignStat`, обновляя `CampaignName`, `CampaignType` и базовые метрики (если есть), **не затирая** детальные срезы. Использовать `ON CONFLICT DO UPDATE`.
        *   Обработка ошибок API на уровне аккаунта.
        *   **UI Feedback (Начало):** Сообщить пользователю о начале обновления (например, через `flash`). Возможно, добавить спиннер/индикатор загрузки.
    *   [ ] **Реализовать Шаг 2: Полная Загрузка Детальной Статистики:**
        *   Функция (вызывается после Шага 1) получает список активных `CampaignId` (из Шага 1 или повторным запросом).
        *   Для каждой кампании (или пачками) запрашиваются **основные отчеты по срезам** (Placement, SearchQuery, Geo и т.д.) за **полные 4 недели**.
        *   Парсинг отчетов.
        *   **`UPSERT`** в соответствующие таблицы `Weekly*Stat` для **всех 4 недель**, обновляя **все** поля.
        *   Детальное логирование ошибок.
        *   **UI Feedback (Конец):** Сообщить пользователю о завершении полного обновления (`flash`). Обновить метку "Последнее обновление".
    *   **Проверка:** Единая кнопка запускает оба шага. Список кампаний в UI обновляется относительно быстро после Шага 1. Полная статистика загружается корректно после Шага 2. Логика `UPSERT` работает.

*   **Подзадача 5.6: Реализация Сбора и Отображения Конверсий**
    *   [ ] Добавить UI для ручного ввода ID целей Метрики (привязать к `Client` или `User`).
    *   [ ] Модифицировать запросы к API Reports (**в Шаге 2 сбора данных**) для передачи `Goals` и запроса полей конверсий.
    *   [ ] Адаптировать модели `Weekly*Stat` (поле `conversions`). Миграция уже должна быть (из Этапа 1).
    *   [ ] Адаптировать парсинг отчетов и запись в БД (**в Шаге 2 сбора данных**).
    *   [ ] Адаптировать UI (`campaign_list`, `campaign_detail`) для отображения Конверсий, CR, CPA (расчет на лету, обработка 0).
    *   **Проверка:** После ввода целей и **полного** обновления данных, конверсии и расчетные метрики отображаются корректно.

*   **Подзадача 5.7: Агрегированный Список Кампаний и Детализация**
    *   [ ] Реализовать роут и шаблон (`reports/campaign_list.html`) для отображения списка кампаний:
        *   **Не запускает сбор данных.**
        *   Делает `SELECT` из **локальной БД** (`WeeklyCampaignStat`) для выбранного `client_id`.
        *   Выбирает данные **только за последнюю доступную неделю**.
        *   Отображает список с основными метриками (включая `CampaignName`, `CampaignType`, конверсии и т.д., доступные после Шага 1 или Шага 2 обновления).
        *   Добавить столбец/индикатор `yandex_account_login`.
        *   **Отобразить дату последнего полного обновления.**
    *   [ ] Реализовать роут `view_campaign_detail`:
        *   **Не запускает сбор данных.**
        *   Читает детальную статистику из **локальной БД** (`Weekly*Stat` по всем срезам) за 4 недели.
        *   Отобразить дату последнего полного обновления.
    *   **Проверка:** Список кампаний загружается быстро из БД. Детализация показывает данные из БД. Актуальность данных соответствует последнему запуску обновления.

**Этап 3: Улучшения и Завершение (Приоритет 3)**

*   **Подзадача 5.8: Надежность API (`tenacity`) и Серверная Сортировка**
    *   [ ] Добавить `tenacity` в `requirements.txt`.
    *   [ ] Обернуть вызовы `requests` в `YandexDirectClient._make_request` декоратором `@retry` (настроить ошибки, задержку, логирование ретраев).
    *   [ ] Реализовать **серверную сортировку** для таблиц в `campaign_detail.html` (Площадки, Запросы).
    *   **Проверка:** Сбор данных устойчив к сбоям API. Таблицы сортируются на сервере.

*   **Подзадача 5.9: Реализация Блокировки Площадок**
    *   [ ] Добавить UI в табе "Площадки" (`campaign_detail.html`).
    *   [ ] Реализовать POST-роут (`/campaign/<campaign_id>/block_placements`). Логика: принять ID площадок, получить токен, **определить тип кампании**, вызвать нужный метод API Директа, использовать `flash`.
    *   **Проверка:** Площадки блокируются в Директе.

*   **Подзадача 5.10: Реализация Скачивания CSV**
    *   [ ] Реализовать/адаптировать роут `download_csv`.
    *   [ ] Логика: выборка из **PostgreSQL**, расчет метрик, формирование CSV (UTF-8), отдача файла.
    *   **Проверка:** Скачивается корректный CSV.

*   **Подзадача 5.11: Качество Кода и Финальная Очистка**
    *   [ ] Настроить и использовать `pre-commit` (`black`, `isort`, `flake8`).
    *   [ ] Убрать тестовые ограничения, добавить docstrings/hints.
    *   [ ] Финальное ручное тестирование MVP в Docker на Production API.
    *   **Проверка:** Код чистый, MVP работает стабильно.

## 5. КЛЮЧЕВЫЕ ПРОДУКТОВЫЕ РИСКИ MVP (Веха 5)

*   **Длительность Полного Обновления:** Шаг 2 может быть долгим для больших аккаунтов. *Смягчение:* Четкая индикация процесса, быстрый Шаг 1 дает ощущение прогресса.
*   **Недельная Гранулярность Данных:** *(Остается)* Снижает оперативность анализа. *Смягчение:* Принять как ограничение MVP, рассмотреть переход на дневную в Вехе 6.
*   **Ручной Ввод ID Целей:** *(Остается)* Неудобно, источник ошибок. *Смягчение:* Сделать UI понятным, запланировать авто-получение.
*   **Отсутствие "Интеллекта":** *(Остается)* MVP - агрегатор. *Смягчение:* Четкое позиционирование.

## 6. ПОТЕНЦИАЛЬНЫЕ ЛОВУШКИ И ТОЧКИ ТЕСТИРОВАНИЯ (Фокус для QA)

*   **Двухэтапный Сбор:**
    *   Что видит пользователь *между* Шагом 1 и Шагом 2? Корректно ли отображается список? Что в деталях?
    *   Что если Шаг 2 падает? Данные остаются от Шага 1 или от предыдущего полного обновления?
    *   Корректность `UPSERT` в обоих шагах (не затираются ли нужные данные).
*   **API Reports без Фильтра:** Точно ли не попадают совсем "мертвые" кампании?
*   **ID Целей:** Ввод несуществующих, неправильных ID.
*   **Расчет Метрик:** Деление на ноль.
*   **API Блокировки Площадок:** Корректность определения типа кампании, лимиты.
*   **CSV:** Кодировка, спецсимволы, производительность.
*   **Права Доступа:** Доступ к чужим данным.
*   **Производительность UI:** Загрузка списка/деталей из БД (должна быть быстрой). Серверная сортировка.

## 7. СТРАТЕГИЧЕСКИЕ ЗАМЕЧАНИЯ И ТЕХНИЧЕСКИЙ ДОЛГ

*   **PostgreSQL vs ClickHouse:** *(Остается)* Postgres - ОК для MVP. Проектировать схему с прицелом на будущее. Добавить индексы.
*   **Недельная vs Дневная Гранулярность:** *(Остается)* Техдолг для AI. Рассмотреть переход в Вехе 6.
*   **Архитектура Обновления:** Единый двухэтапный процесс — **хорошее решение**, легко переносится на фоновые задачи (Celery/RQ).
*   **Мониторинг:** Логирование есть. Подумать о метриках времени выполнения Шага 1 и Шага 2.

## 8. Логика Работы с Документацией

*   Обновлять секцию "Текущий Статус" этого файла (`PROJECT_README.md`) после **каждой выполненной подзадачи**, отмечая ее как `[x]`.
*   При возникновении проблем или изменении решений - фиксировать их здесь.
*   **В конце Вехи 5:** Финализировать этот документ, обновить `BUSINESS_LOGIC.md` (если были отклонения), подготовить план на Веху 6.

## 9. Следующие Шаги (После Вехи 5 - MVP)

*   **Веха 6: Автоматизация, Улучшения, Подготовка к AI**
    *   **Приоритет 1:** Автоматический еженедельный (или ежедневный?) сбор данных (Celery/RQ).
    *   **Приоритет 2:** Переход на **дневную гранулярность** данных (требует решения и оценки).
    *   **Приоритет 3:** Автоматическое получение списка целей из Яндекс.Метрики.
    *   Реализация ввода/хранения/визуализации KPI.
    *   Улучшения UX (фильтры, графики?).
    *   Оптимизация производительности (если нужно).
*   **Веха 7: Интеграция AI (Шаг 1 - Hi-Level Анализ)**
*   **Веха 8: Интеграция AI (Шаг 2 - Анализ по Срезам) + Минусация**
*   **Веха 9: Контроль Бюджета и Другие Фичи**

---